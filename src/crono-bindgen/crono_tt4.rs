/* automatically generated by rust-bindgen 0.58.1 */

pub const CRONO_OK: u32 = 0;
pub const CRONO_WINDRIVER_NOT_FOUND: u32 = 1;
pub const CRONO_DEVICE_NOT_FOUND: u32 = 2;
pub const CRONO_NOT_INITIALIZED: u32 = 3;
pub const CRONO_WRONG_STATE: u32 = 4;
pub const CRONO_INVALID_DEVICE: u32 = 5;
pub const CRONO_BUFFER_ALLOC_FAILED: u32 = 6;
pub const CRONO_TDC_NO_EDGE_FOUND: u32 = 7;
pub const CRONO_INVALID_BUFFER_PARAMETERS: u32 = 8;
pub const CRONO_INVALID_CONFIG_PARAMETERS: u32 = 9;
pub const CRONO_WINDOW_CALIBRATION_FAILED: u32 = 10;
pub const CRONO_HARDWARE_FAILURE: u32 = 11;
pub const CRONO_INVALID_ADC_MODE: u32 = 12;
pub const CRONO_SYNCHRONIZATION_FAILED: u32 = 13;
pub const CRONO_DEVICE_OPEN_FAILED: u32 = 14;
pub const CRONO_INTERNAL_ERROR: u32 = 15;
pub const CRONO_PACKET_TYPE_8_BIT_SIGNED: u32 = 0;
pub const CRONO_PACKET_TYPE_16_BIT_SIGNED: u32 = 1;
pub const CRONO_PACKET_TYPE_32_BIT_SIGNED: u32 = 2;
pub const CRONO_PACKET_TYPE_64_BIT_SIGNED: u32 = 3;
pub const CRONO_PACKET_TYPE_8_BIT_UNSIGNED: u32 = 4;
pub const CRONO_PACKET_TYPE_16_BIT_UNSIGNED: u32 = 5;
pub const CRONO_PACKET_TYPE_32_BIT_UNSIGNED: u32 = 6;
pub const CRONO_PACKET_TYPE_64_BIT_UNSIGNED: u32 = 7;
pub const CRONO_PACKET_TYPE_TIMESTAMP_ONLY: u32 = 128;
pub const CRONO_PACKET_TYPE_END_OF_BUFFER: u32 = 129;
pub const CRONO_PACKET_TYPE_TRIGGER_PATTERN: u32 = 130;
pub const CRONO_PACKET_FLAG_SHORTENED: u32 = 1;
pub const CRONO_PACKET_FLAG_PACKETS_LOST: u32 = 2;
pub const CRONO_PACKET_FLAG_OVERFLOW: u32 = 4;
pub const CRONO_PACKET_FLAG_TRIGGER_MISSED: u32 = 8;
pub const CRONO_PACKET_FLAG_DMA_FIFO_FULL: u32 = 16;
pub const CRONO_PACKET_FLAG_HOST_BUFFER_FULL: u32 = 32;
pub const CRONO_PACKET_FLAG_TDC_NO_EDGE: u32 = 64;
pub const CRONO_DEVICE_UNKNOWN: u32 = 0;
pub const CRONO_DEVICE_HPTDC: u32 = 1;
pub const CRONO_DEVICE_NDIGO5G: u32 = 2;
pub const CRONO_DEVICE_NDIGO250M: u32 = 4;
pub const CRONO_DEVICE_NDIGO_AVRG: u32 = 3;
pub const CRONO_DEVICE_XTDC4: u32 = 6;
pub const CRONO_DEVICE_FMC_TDC10: u32 = 7;
pub const CRONO_DEVICE_TIMETAGGER4: u32 = 8;
pub const CRONO_DEVICE_D_AVE12: u32 = 9;
pub const CRONO_DEVICE_D_AVE14: u32 = 10;
pub const CRONO_DEVICE_NDIGO2G14: u32 = 11;
pub const CRONO_READ_OK: u32 = 0;
pub const CRONO_READ_NO_DATA: u32 = 1;
pub const CRONO_READ_INTERNAL_ERROR: u32 = 2;
pub const CRONO_READ_TIMEOUT: u32 = 3;
pub const TDC4_API_VERSION: u32 = 0;
pub const TDC4_TDC_CHANNEL_COUNT: u32 = 4;
pub const TDC4_LOWRES_CHANNEL_COUNT: u32 = 3;
pub const TDC4_TIGER_COUNT: u32 = 5;
pub const TDC4_TRIGGER_COUNT: u32 = 16;
pub const TDC4_RCLK_37M5: u32 = 0;
pub const TDC4_RCLK_75M: u32 = 1;
pub const TDC4_RCLK_150M: u32 = 2;
pub const TIMETAGGER4_API_VERSION: u32 = 0;
pub const TIMETAGGER4_TDC_CHANNEL_COUNT: u32 = 4;
pub const TIMETAGGER4_LOWRES_CHANNEL_COUNT: u32 = 3;
pub const TIMETAGGER4_TIGER_COUNT: u32 = 5;
pub const TIMETAGGER4_TRIGGER_COUNT: u32 = 16;
pub const TIMETAGGER4_BUFFER_ALLOCATE: u32 = 0;
pub const TIMETAGGER4_BUFFER_USE_PHYSICAL: u32 = 1;
pub const TIMETAGGER4_TDC_MODE_GROUPED: u32 = 0;
pub const TIMETAGGER4_TDC_MODE_CONTINUOUS: u32 = 1;
pub const TIMETAGGER4_DC_OFFSET_P_NIM: f64 = 0.35;
pub const TIMETAGGER4_DC_OFFSET_P_CMOS: f64 = 1.18;
pub const TIMETAGGER4_DC_OFFSET_P_LVCMOS_33: f64 = 1.18;
pub const TIMETAGGER4_DC_OFFSET_P_LVCMOS_25: f64 = 1.18;
pub const TIMETAGGER4_DC_OFFSET_P_LVCMOS_18: f64 = 0.9;
pub const TIMETAGGER4_DC_OFFSET_P_TTL: f64 = 1.18;
pub const TIMETAGGER4_DC_OFFSET_P_LVTTL_33: f64 = 1.18;
pub const TIMETAGGER4_DC_OFFSET_P_LVTTL_25: f64 = 1.18;
pub const TIMETAGGER4_DC_OFFSET_P_SSTL_3: f64 = 1.18;
pub const TIMETAGGER4_DC_OFFSET_P_SSTL_2: f64 = 1.18;
pub const TIMETAGGER4_DC_OFFSET_N_NIM: f64 = -0.35;
pub const TIMETAGGER4_DC_OFFSET_N_CMOS: f64 = -1.32;
pub const TIMETAGGER4_DC_OFFSET_N_LVCMOS_33: f64 = -1.32;
pub const TIMETAGGER4_DC_OFFSET_N_LVCMOS_25: f64 = -1.25;
pub const TIMETAGGER4_DC_OFFSET_N_LVCMOS_18: f64 = -0.9;
pub const TIMETAGGER4_DC_OFFSET_N_TTL: f64 = -1.32;
pub const TIMETAGGER4_DC_OFFSET_N_LVTTL_33: f64 = -1.32;
pub const TIMETAGGER4_DC_OFFSET_N_LVTTL_25: f64 = -1.25;
pub const TIMETAGGER4_DC_OFFSET_N_SSTL_3: f64 = -1.32;
pub const TIMETAGGER4_DC_OFFSET_N_SSTL_2: f64 = -1.25;
pub const TIMETAGGER4_TRIGGER_SOURCE_S: u32 = 1;
pub const TIMETAGGER4_TRIGGER_SOURCE_A: u32 = 2;
pub const TIMETAGGER4_TRIGGER_SOURCE_B: u32 = 4;
pub const TIMETAGGER4_TRIGGER_SOURCE_C: u32 = 8;
pub const TIMETAGGER4_TRIGGER_SOURCE_D: u32 = 16;
pub const TIMETAGGER4_TRIGGER_SOURCE_S1: u32 = 32;
pub const TIMETAGGER4_TRIGGER_SOURCE_S2: u32 = 64;
pub const TIMETAGGER4_TRIGGER_SOURCE_GATE: u32 = 128;
pub const TIMETAGGER4_TRIGGER_SOURCE_AUTO: u32 = 16384;
pub const TIMETAGGER4_TRIGGER_SOURCE_ONE: u32 = 32768;
pub const TIMETAGGER4_PACKET_FLAG_ODD_HITS: u32 = 1;
pub const TIMETAGGER4_PACKET_FLAG_SLOW_SYNC: u32 = 2;
pub const TIMETAGGER4_PACKET_FLAG_START_MISSED: u32 = 4;
pub const TIMETAGGER4_PACKET_FLAG_SHORTENED: u32 = 8;
pub const TIMETAGGER4_PACKET_FLAG_DMA_FIFO_FULL: u32 = 16;
pub const TIMETAGGER4_PACKET_FLAG_HOST_BUFFER_FULL: u32 = 32;
pub const TIMETAGGER4_HIT_FLAG_RISING: u32 = 1;
pub const TIMETAGGER4_HIT_FLAG_TIME_OVERFLOW: u32 = 2;
pub const TIMETAGGER4_HIT_FLAG_COARSE_TIMESTAMP: u32 = 4;
pub const TIMETAGGER4_HIT_FLAG_TDC_MISSING: u32 = 4;
pub const TIMETAGGER4_HIT_FLAG_FPGA_MISSING: u32 = 8;
pub const TIMETAGGER4_OK: u32 = 0;
pub const TIMETAGGER4_WINDRIVER_NOT_FOUND: u32 = 1;
pub const TIMETAGGER4_DEVICE_NOT_FOUND: u32 = 2;
pub const TIMETAGGER4_NOT_INITIALIZED: u32 = 3;
pub const TIMETAGGER4_INVALID_DEVICE: u32 = 5;
pub const TIMETAGGER4_BUFFER_ALLOC_FAILED: u32 = 6;
pub const TIMETAGGER4_TDC_NO_EDGE_FOUND: u32 = 7;
pub const TIMETAGGER4_INVALID_BUFFER_PARAMETERS: u32 = 8;
pub const TIMETAGGER4_INVALID_CONFIG_PARAMETERS: u32 = 9;
pub const TIMETAGGER4_WINDOW_CALIBRATION_FAILED: u32 = 10;
pub const TIMETAGGER4_HARDWARE_FAILURE: u32 = 11;
pub const TIMETAGGER4_INVALID_TDC_MODE: u32 = 12;
pub const TIMETAGGER4_SYNCHRONIZATION_FAILED: u32 = 13;
pub const TIMETAGGER4_DEVICE_OPEN_FAILED: u32 = 14;
pub const TIMETAGGER4_WRONG_STATE: u32 = 4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crono_device {
    pub device_type: ::std::os::raw::c_int,
    #[doc = " For HPTDC use this board id, Ndigo uses configured board id"]
    pub board_id: ::std::os::raw::c_int,
    pub device: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crono_packet {
    pub channel: ::std::os::raw::c_uchar,
    pub card: ::std::os::raw::c_uchar,
    pub type_: ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_uchar,
    pub length: ::std::os::raw::c_uint,
    pub timestamp: ::std::os::raw::c_longlong,
    pub data: [::std::os::raw::c_ulonglong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crono_packet_only_timestamp {
    pub channel: ::std::os::raw::c_uchar,
    pub card: ::std::os::raw::c_uchar,
    pub type_: ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_uchar,
    pub length: ::std::os::raw::c_uint,
    pub timestamp: ::std::os::raw::c_longlong,
}
#[doc = "\t\\ingroup initparamsstruct"]
#[doc = "\t\\brief struct for the initialization of the xTDC4"]
#[doc = ""]
#[doc = "\tthis structure MUST be completely INITIALIZED"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_init_parameters {
    #[doc = " \\brief the version number"]
    #[doc = ""]
    #[doc = "\tmust be set to @link apiversion XTDC4_API_VERSION @endlink"]
    pub version: ::std::os::raw::c_int,
    #[doc = " \\brief The index in the list of XTDC4 boards that should be initialized."]
    #[doc = ""]
    #[doc = "\tThere might be multiple boards in the system that are handled by this driver as reported by @link"]
    #[doc = "\tinitialization ndigo_count_devices() @endlink. This index selects one of them. Boards are enumerated"]
    #[doc = "\tdepending on the PCIe slot. The lower the bus number and the lower the slot number the lower the card"]
    #[doc = "\tindex."]
    pub card_index: ::std::os::raw::c_int,
    #[doc = " \\brief the global index in all cronologic devices"]
    #[doc = ""]
    #[doc = "\tThis 8 bit number is filled into each packet created by the board and is useful if data streams of"]
    #[doc = "\tmultiple boards will be merged. If only XTDC4 cards are used this number can be set to the"]
    #[doc = "\t@link card_index card_index @endlink. If boards of different types that use a compatible data format"]
    #[doc = "\tare used in a system each board should get a unique id."]
    pub board_id: ::std::os::raw::c_int,
    #[doc = "\t\\brief The minimum size of the DMA buffer."]
    #[doc = ""]
    #[doc = "\tIf set to 0 the default size of 16MB is used."]
    #[doc = "\tFor the xtdc4 only the first entry is used."]
    pub buffer_size: [::std::os::raw::c_longlong; 8usize],
    #[doc = "\t\\brief The type of buffer"]
    #[doc = ""]
    #[doc = "\tCan be either allocated (only option currently) or physical."]
    #[doc = "\tPlease refer to group @link buffertype #defines of buffer_type @endlink."]
    pub buffer_type: ::std::os::raw::c_int,
    #[doc = "\t\\brief The start address of the reserved memory."]
    #[doc = ""]
    #[doc = "\tThe buffers will be allocated with the sizes given above. Make sure that the memory"]
    #[doc = "\tis large enough."]
    pub buffer_address: ::std::os::raw::c_longlong,
    #[doc = " \\brief A variant, for reconfiguring the chip for future extension"]
    #[doc = ""]
    pub variant: ::std::os::raw::c_int,
    #[doc = " \\brief A constant for the different devices of cronologic CRONO_DEVICE_*."]
    #[doc = ""]
    #[doc = "\tInitialized by @link initialization xtdc4_get_default_init_parameters() @endlink."]
    #[doc = "\tMust be left unchanged. Please refer to @link devicetype #define for device_type @endlink."]
    pub device_type: ::std::os::raw::c_int,
    #[doc = " \\brief The update delay of the writing pointer after a packet has been send over PCIe."]
    #[doc = ""]
    #[doc = "\tThe base unit is 16 to 32 ns."]
    pub dma_read_delay: ::std::os::raw::c_int,
    #[doc = " \\brief Select external 10 MHz reference."]
    #[doc = ""]
    #[doc = "  If set to 1 use external 10 MHz reference."]
    #[doc = "  If set to 0 use internal reference."]
    pub use_ext_clock: ::std::os::raw::c_int,
    #[doc = " \\brief Set THS788 RClk frequency, default is 150 MHz."]
    #[doc = ""]
    #[doc = " 0: 37.5 MHz"]
    #[doc = " 1: 75 MHz"]
    #[doc = " 2: 150 MHz"]
    pub rclk_sel: ::std::os::raw::c_int,
}
#[doc = " \\ingroup staticinfo"]
#[doc = "\t\\brief Structure contains static information"]
#[doc = ""]
#[doc = "\tThis structure contains information about the board that does not change during run time."]
#[doc = "\tIt is provided by the function @link statfuncts xtdc4_get_static_info() @endlink."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_static_info {
    #[doc = "!< The number of bytes occupied by the structure"]
    pub size: ::std::os::raw::c_int,
    #[doc = "!< The version number"]
    pub version: ::std::os::raw::c_int,
    #[doc = "\t\\brief ID of the board."]
    #[doc = ""]
    #[doc = "\tThis value is passed to the constructor. It is reflected in the\toutput data."]
    pub board_id: ::std::os::raw::c_int,
    #[doc = "\t\\brief encoded version number"]
    #[doc = ""]
    #[doc = "\tThe lower three bytes contain a triple level hierarchy of version numbers."]
    #[doc = "\tE.g. 0x010103 codes version 1.1.3."]
    #[doc = ""]
    #[doc = "\tA change in the first digit generally requires"]
    #[doc = "\ta recompilation of user applications. Change in the second digit denote significant"]
    #[doc = "\timprovements or changes that don't break compatibility and the third digit changes"]
    #[doc = "\twith minor bugfixes and the like."]
    pub driver_revision: ::std::os::raw::c_int,
    #[doc = "!< Revision number of the FPGA configuration."]
    pub firmware_revision: ::std::os::raw::c_int,
    #[doc = "\t\\brief board revision number"]
    #[doc = ""]
    #[doc = "\tThe board revision number can be read from a register. It is a four bit number"]
    #[doc = "\tthat changes when the schematic of the board is changed."]
    #[doc = "\t- 0: Experimental first board Version. Labeled \"Rev. 1\""]
    #[doc = "\t- 2: First commercial Version. Labeled \"Rev. 2\""]
    pub board_revision: ::std::os::raw::c_int,
    #[doc = "\t\\brief Describes the schematic configuration of the board."]
    #[doc = ""]
    #[doc = "\tThe same board schematic can be populated in multiple variants. This is a eight"]
    #[doc = "\tbit code that can be read from a register."]
    pub board_configuration: ::std::os::raw::c_int,
    #[doc = "!< Subversion revision id of the FPGA configuration."]
    pub subversion_revision: ::std::os::raw::c_int,
    #[doc = "!< 16bit factory ID of the TDC chip."]
    pub chip_id: ::std::os::raw::c_int,
    #[doc = "\t\\brief Serial number"]
    #[doc = ""]
    #[doc = "\twith year and running number in 8.24 format. The number is identical to the one"]
    #[doc = "\tprinted on the silvery sticker on the board."]
    pub board_serial: ::std::os::raw::c_int,
    #[doc = "!< low 32 bits of 64 bit manufacturer serial number of the flash chip"]
    pub flash_serial_low: ::std::os::raw::c_uint,
    #[doc = "!< high 32 bits of 64 bit manufacturer serial number of the flash chip"]
    pub flash_serial_high: ::std::os::raw::c_uint,
    #[doc = "\t\\brief Flash data is valid and in use"]
    #[doc = ""]
    #[doc = "\tIf not 0 the driver found valid calibration data in the flash on the board and is using it."]
    pub flash_valid: ::std::os::raw::c_int,
    #[doc = " \\brief calibration date"]
    #[doc = ""]
    #[doc = " DIN EN ISO 8601 string YYYY-MM-DD HH:DD describing the time when the card was calibrated."]
    pub calibration_date: [::std::os::raw::c_char; 20usize],
}
#[doc = " \\ingroup fastinfo"]
#[doc = "\t\\brief contains fast dynamic information"]
#[doc = ""]
#[doc = "\tThis call returns a structure that contains dynamic information that can be obtained"]
#[doc = "\twithin a few microseconds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_fast_info {
    #[doc = "!< The number of bytes occupied by the structure"]
    pub size: ::std::os::raw::c_int,
    #[doc = "!< The version number"]
    pub version: ::std::os::raw::c_int,
    #[doc = " \\brief Speed of the TDC fan."]
    #[doc = ""]
    #[doc = "\tReports 0, if no fan is present"]
    pub tdc_rpm: ::std::os::raw::c_int,
    #[doc = " \\brief Speed of the FPGA fan."]
    #[doc = ""]
    #[doc = " Reports 0, if no fan is present."]
    pub fpga_rpm: ::std::os::raw::c_int,
    #[doc = "\t\\brief Alert bits from temperature sensor and the system monitor"]
    #[doc = ""]
    #[doc = "\t- bit 0:\tTHS788 over temperature alarm"]
    pub alerts: ::std::os::raw::c_int,
    #[doc = " \\brief organizes power supply of PCIe lanes."]
    pub pcie_pwr_mgmt: ::std::os::raw::c_int,
    #[doc = "!< Number of PCIe lanes the card uses."]
    pub pcie_link_width: ::std::os::raw::c_int,
    #[doc = "\t\\brief Maximum size for a single PCIe transaction"]
    #[doc = "  in bytes. Depends on system configuration."]
    pub pcie_max_payload: ::std::os::raw::c_int,
}
#[doc = " \\ingroup paraminfo"]
#[doc = "\t\\brief contains configuration changes"]
#[doc = ""]
#[doc = "\tStructure filled by @link statfuncts xtdc4_get_param_info() @endlink. This structure"]
#[doc = "\tcontains information that change indirectly due to configuration changes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_param_info {
    #[doc = "!< The number of bytes occupied by the structure"]
    pub size: ::std::os::raw::c_int,
    #[doc = "!< The version number"]
    pub version: ::std::os::raw::c_int,
    #[doc = "\t\\brief Binsize (in ps) of the measured TDC data."]
    #[doc = ""]
    #[doc = "\tThe TDC main clk is running at a frequency of 76.8 GHz"]
    #[doc = "  resulting in a binsize of ~13.0208 ps."]
    pub binsize: f64,
    #[doc = "\t\\brief Board ID"]
    #[doc = ""]
    #[doc = "\tThe board uses this ID to identify itself in the output data stream. The ID takes"]
    #[doc = "\tvalues between 0 and 255."]
    pub board_id: ::std::os::raw::c_int,
    #[doc = "\t\\brief Number of channels in the current TDC mode"]
    #[doc = ""]
    #[doc = " Currently fixed at 4."]
    pub channels: ::std::os::raw::c_int,
    #[doc = " \\brief bit assignment of each enabled input channel."]
    #[doc = ""]
    #[doc = "\tMask assigns a certain bit to each enabled input channel."]
    pub channel_mask: ::std::os::raw::c_int,
    #[doc = "!< The total amount of DMA buffer in bytes."]
    pub total_buffer: ::std::os::raw::c_longlong,
}
#[doc = "\t\\ingroup channel"]
#[doc = "\t\\brief Contains TDC channel settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_channel {
    #[doc = "!< Enable TDC channel."]
    pub enabled: ::std::os::raw::c_uchar,
    #[doc = "!< Set whether to record rising or falling edges."]
    pub rising: ::std::os::raw::c_uchar,
    #[doc = "!< Enable carry chain TDC as backup"]
    pub cc_enable: ::std::os::raw::c_uchar,
    #[doc = "!< Set whether the carry chain TDC records the same edge as THS788 (as backup) or opposite edge"]
    pub cc_same_edge: ::std::os::raw::c_uchar,
    #[doc = "!< Disable THS788 timestamps"]
    pub ths788_disable: ::std::os::raw::c_uchar,
    #[doc = "\t\\brief Veto function"]
    #[doc = ""]
    #[doc = "\tonly timestamps >= start are recorded."]
    pub start: ::std::os::raw::c_int,
    #[doc = "\t\\brief Veto function"]
    #[doc = ""]
    #[doc = "\tonly timestamps <= stop are recorded."]
    pub stop: ::std::os::raw::c_int,
}
#[doc = "\t\\ingroup lowres_channel"]
#[doc = "\t\\brief Contains digital channel settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_lowres_channel {
    #[doc = "!< Enable TDC channel."]
    pub enabled: ::std::os::raw::c_uchar,
    #[doc = "\t\\brief Veto function"]
    #[doc = ""]
    #[doc = "\tonly timestamps >= start are recorded."]
    pub start: ::std::os::raw::c_int,
    #[doc = "\t\\brief Veto function"]
    #[doc = ""]
    #[doc = "\tonly timestamps <= stop are recorded."]
    pub stop: ::std::os::raw::c_int,
}
#[doc = "\t\\ingroup tiger"]
#[doc = "\t\\brief contains settings of timing generator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_tiger_block {
    #[doc = "!< activates timing generator"]
    pub enable: ::std::os::raw::c_uchar,
    #[doc = " \\brief inverts output polarity"]
    #[doc = ""]
    #[doc = " default is set to false."]
    pub negate: ::std::os::raw::c_uchar,
    #[doc = "\t\\brief enables/disables retrigger setting"]
    #[doc = ""]
    #[doc = "\tDefault is set to false. If retriggering is enabled the timer is reset to the value of the start"]
    #[doc = "\tparameter, whenever the input signal is set while waiting to reach the stop time."]
    pub retrigger: ::std::os::raw::c_uchar,
    #[doc = "!< not implemented"]
    pub extend: ::std::os::raw::c_uchar,
    #[doc = "!< enables the LEMO output"]
    pub enable_lemo_output: ::std::os::raw::c_uchar,
    #[doc = " \\brief Precursor"]
    #[doc = ""]
    #[doc = "  Number of 6.6ns clock cycles before the tiger output goes active"]
    #[doc = "\trelative to the trigger signal."]
    pub start: ::std::os::raw::c_int,
    #[doc = " \\brief postcursor"]
    #[doc = ""]
    #[doc = "  Number of 6.6ns clock cycles before the tiger output goes inactive"]
    #[doc = "\trelative to the trigger signal."]
    pub stop: ::std::os::raw::c_int,
    #[doc = "\t\\brief mask for choosing the trigger source"]
    #[doc = ""]
    #[doc = "\tA bit mask with a bit set for all trigger sources that can trigger this channel. Default is"]
    #[doc = "\tXTDC4_TRIGGER_SOURCE_S. One can choose a from a source @link deftriggersource here @endlink."]
    pub sources: ::std::os::raw::c_int,
}
#[doc = "\\ingroup trigger"]
#[doc = "\t\\brief contains trigger settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_trigger {
    #[doc = "!< triggers on falling edges"]
    pub falling: ::std::os::raw::c_uchar,
    #[doc = "!< triggers on rising edges"]
    pub rising: ::std::os::raw::c_uchar,
}
#[doc = " \\ingroup confstruct Structure xtdc4_configuration"]
#[doc = "\t\\brief\tcontains configuration information"]
#[doc = ""]
#[doc = "\tThis structure contains the configuration information. It is used in conjunction with"]
#[doc = "\t@link conffuncts xtdc4_get_default_configuration(), xtdc4_get_current_configuration()"]
#[doc = "\tand xtdc4_configure() @endlink"]
#[doc = ""]
#[doc = "\tInternally it uses the structures @link trigger xtdc4_trigger @endlink and @link tiger"]
#[doc = "\txtdc4_tiger_block @endlink"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_configuration {
    #[doc = "!< The number of bytes occupied by the structure"]
    pub size: ::std::os::raw::c_int,
    #[doc = " \\brief A version number"]
    #[doc = ""]
    #[doc = " that is increased when the definition of the structure is changed. The increment"]
    #[doc = " can be larger than one to match driver version numbers or similar. Set to 0 for"]
    #[doc = " all versions up to first release."]
    pub version: ::std::os::raw::c_int,
    #[doc = " \\brief TDC mode"]
    #[doc = ""]
    #[doc = "\tcan be @link tdcmode grouped or continous @endlink. Currently supported: grouped."]
    pub tdc_mode: ::std::os::raw::c_int,
    #[doc = " \\brief rising or falling edge trigger"]
    #[doc = ""]
    #[doc = "\twhether to sync the TDC on the rising or falling edge"]
    pub start_rising: ::std::os::raw::c_uchar,
    #[doc = " \\brief Set DAC channels for T, A - D."]
    #[doc = ""]
    #[doc = "\tdc_offset[0]     : Start"]
    #[doc = ""]
    #[doc = "\tdc_offset[1 - 4] : A - D"]
    #[doc = ""]
    #[doc = "\tSet to a value between -1.65V and +0.85V. This should be close to 50% of the height of your pulses on"]
    #[doc = "\tthe inputs. Examples for various signaling standards are defined in @link defdcoffset #defines for"]
    #[doc = "\tdc_offset @endlink. The inputs are AC coupled. This means that for pulse inputs the absolute voltage is"]
    #[doc = "\tnot important. it is rather the relative pulse amplitude that causes the input circuits to switch."]
    #[doc = "\tdc_offset for an input must be set to the relative switching voltage for the input standard in use. If"]
    #[doc = "\tthe pulses are negative, a negative switching threshold must be set and vice versa."]
    pub dc_offset: [f64; 5usize],
    #[doc = "!< Configuration of external trigger sources"]
    pub trigger: [tdc4_trigger; 16usize],
    #[doc = "!< configuration of the timing generator"]
    pub tiger_block: [tdc4_tiger_block; 5usize],
    #[doc = "!< configure polaritiy, type and threshold for the TDC channels"]
    pub channel: [tdc4_channel; 4usize],
    #[doc = "!< configure polaritiy, type and threshold for the digital channels"]
    pub lowres_channel: [tdc4_lowres_channel; 3usize],
    #[doc = " \\brief component to create a trigger either periodically or randomly."]
    #[doc = ""]
    #[doc = "  To be exact, there are two parameters M = @link auto_trigger_period auto_trigger_period @endlink"]
    #[doc = "\tand N = @link auto_trigger_random_exponent auto_trigger_random_exponent @endlink"]
    #[doc = "\tthat result in a distance between triggers of"]
    #[doc = ""]
    #[doc = "\t\tT = 1 + M + [1...2^N]"]
    #[doc = ""]
    #[doc = "\tclock cycles."]
    #[doc = ""]
    #[doc = "\t\t0 <= M < 2^32"]
    #[doc = ""]
    #[doc = "\t\t0 <= N < 32"]
    #[doc = ""]
    #[doc = "  there is no enable or reset as the usage of this trigger can be configured in the channels."]
    pub auto_trigger_period: ::std::os::raw::c_int,
    #[doc = " \\brief component to create a trigger either periodically or randomly."]
    #[doc = ""]
    #[doc = "  To be exact, there are two parameters M = @link auto_trigger_period auto_trigger_period @endlink"]
    #[doc = "\tand N = @link auto_trigger_random_exponent auto_trigger_random_exponent @endlink"]
    #[doc = "\tthat result in a distance between triggers of"]
    #[doc = ""]
    #[doc = "\t\tT = 1 + M + [1...2^N]"]
    #[doc = ""]
    #[doc = "\tclock cycles."]
    #[doc = ""]
    #[doc = "\t\t0 <= M < 2^32"]
    #[doc = ""]
    #[doc = "\t\t0 <= N < 32"]
    #[doc = ""]
    #[doc = "  there is no enable or reset as the usage of this trigger can be configured in the channels."]
    pub auto_trigger_random_exponent: ::std::os::raw::c_int,
}
#[doc = "\t\\ingroup readin"]
#[doc = "\t\\brief The parameters of the read commands"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_read_in {
    #[doc = "!< xtdc4_read automatically acknowledges packets from the last read"]
    pub acknowledge_last_read: ::std::os::raw::c_uchar,
}
#[doc = " \\ingroup strucreadout"]
#[doc = "\t\\brief struct for the read out of the Ndigo packets"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tdc4_read_out {
    #[doc = "\t\\brief pointer to the first packet"]
    #[doc = ""]
    #[doc = "\tthat was captured by the call of @link readout xtdc4_read @endlink"]
    pub first_packet: *mut crono_packet,
    #[doc = "\t\\brief The packet after the last one"]
    #[doc = ""]
    #[doc = "\tthis is not a valid packet"]
    pub last_packet: *mut crono_packet,
    #[doc = " \\brief error code"]
    #[doc = ""]
    #[doc = "\tThe assignments of the error codes can be found @link deferror here @endlink."]
    pub error_code: ::std::os::raw::c_int,
    #[doc = "\t\\brief error message"]
    pub error_message: *const ::std::os::raw::c_char,
}
#[doc = "\\ingroup device"]
#[doc = " \\brief struct storing properties of the device in use"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timetagger4_device {
    #[doc = " \\brief timetagger4"]
    pub timetagger4: *mut ::std::os::raw::c_void,
}
#[doc = "\t\\ingroup initparamsstruct"]
#[doc = "\t\\brief struct for the initialization of the TimeTagger4"]
#[doc = ""]
#[doc = "\tthis structure MUST be completely INITIALIZED"]
pub type timetagger4_init_parameters = tdc4_init_parameters;
extern "C" {
    #[doc = "\t\\ingroup initfuncts"]
    #[doc = "\t\\brief finalize the driver for this device"]
    #[doc = ""]
    #[doc = "\tReturn values are listed @link defclose here @endlink."]
    #[doc = "\t\\param *device is type @link timetagger4_device timetagger4_device @endlink"]
    pub fn timetagger4_close(device: *mut timetagger4_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup runtime"]
    #[doc = "\t\\brief start timing generator"]
    #[doc = "\t\\param *device is type @link timetagger4_device timetagger4_device @endlink"]
    pub fn timetagger4_start_tiger(device: *mut timetagger4_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup runtime"]
    #[doc = "\t\\brief stop timing generator"]
    #[doc = "\t\\param *device is type @link timetagger4_device timetagger4_device @endlink"]
    pub fn timetagger4_stop_tiger(device: *mut timetagger4_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup runtime"]
    #[doc = "\t\\brief start data acquisition"]
    #[doc = ""]
    #[doc = "\tReturn values are listed @link defstartcap here @endlink."]
    #[doc = "\t\\param *device is type @link timetagger4_device timetagger4_device @endlink"]
    pub fn timetagger4_start_capture(device: *mut timetagger4_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup runtime"]
    #[doc = "\t\\brief\tpause data acquisition"]
    #[doc = ""]
    #[doc = "\tReturn values are listed @link defpausecap here @endlink."]
    #[doc = "\t\\param *device is type @link timetagger4_device timetagger4_device @endlink"]
    pub fn timetagger4_pause_capture(device: *mut timetagger4_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup runtime"]
    #[doc = "\t\\brief resume data acquisition"]
    #[doc = ""]
    #[doc = "\tCall this to resume data acquisition after a call to timetagger4_pause_capture."]
    #[doc = "\tReturn values are listed @link defcontcap here @endlink."]
    #[doc = "\t\\param *device is type @link timetagger4_device timetagger4_device @endlink"]
    pub fn timetagger4_continue_capture(device: *mut timetagger4_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup runtime"]
    #[doc = "\t\\brief\tstop data acquisition"]
    #[doc = ""]
    #[doc = "\tReturn values are listed @link defstopcap here @endlink."]
    #[doc = "\t\\param *device is type @link timetagger4_device timetagger4_device @endlink"]
    pub fn timetagger4_stop_capture(device: *mut timetagger4_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup readout"]
    #[doc = "\t\\brief acknowledges the processing of the last read block"]
    #[doc = ""]
    #[doc = "\tthis is only necessary if read is not called. Return values are listed @link defack here @endlink."]
    #[doc = "\t\\param *device is type @link timetagger4_device timetagger4_device @endlink"]
    #[doc = "\t\\param *packet is type crono_packet"]
    pub fn timetagger4_acknowledge(
        device: *mut timetagger4_device,
        packet: *mut crono_packet,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\ingroup staticinfo"]
#[doc = "\t\\brief Structure contains static information"]
#[doc = ""]
#[doc = "\tThis structure contains information about the board that does not change during run time."]
#[doc = "\tIt is provided by the function @link statfuncts timetagger4_get_static_info() @endlink."]
pub type timetagger4_static_info = tdc4_static_info;
extern "C" {
    #[doc = " \\ingroup statfuncts"]
    #[doc = "\t\\brief contains static information"]
    #[doc = ""]
    #[doc = "\tGets a structure that contains information about the board that does not change during"]
    #[doc = "\trun time. Return values are listed @link defstatinfo here @endlink."]
    #[doc = "\t\\param *device of type timetagger4_device"]
    #[doc = "\t\\param *info of type timetagger4_static_info"]
    pub fn timetagger4_get_static_info(
        device: *mut timetagger4_device,
        info: *mut timetagger4_static_info,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\ingroup fastinfo"]
#[doc = "\t\\brief contains fast dynamic information"]
#[doc = ""]
#[doc = "\tThis call returns a structure that contains dynamic information that can be obtained"]
#[doc = "\twithin a few microseconds."]
pub type timetagger4_fast_info = tdc4_fast_info;
extern "C" {
    #[doc = " \\ingroup statfuncts"]
    #[doc = "\t\\brief returns fast dynamic information"]
    #[doc = ""]
    #[doc = "\tThis call gets a structure that contains dynamic information that can be obtained within a"]
    #[doc = "\tfew microseconds. Return values are listed @link deffastinfo here @endlink."]
    #[doc = "\t\\param *device of type timetagger4_device"]
    #[doc = "\t\\param *info of type timetagger4_fast_info"]
    pub fn timetagger4_get_fast_info(
        device: *mut timetagger4_device,
        info: *mut timetagger4_fast_info,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\ingroup paraminfo"]
#[doc = "\t\\brief contains configuration changes"]
#[doc = ""]
#[doc = "\tStructure filled by @link statfuncts timetagger4_get_param_info() @endlink. This structure"]
#[doc = "\tcontains information that change indirectly due to configuration changes."]
pub type timetagger4_param_info = tdc4_param_info;
extern "C" {
    #[doc = " \\ingroup statfuncts"]
    #[doc = "\t\\brief returns configuration changes"]
    #[doc = ""]
    #[doc = "\tGets a structure that contains information that changes indirectly due to configuration"]
    #[doc = "\tchanges. Return values are listed @link defparaminfo here @endlink."]
    #[doc = "\t\\param *device of type timetagger4_device"]
    #[doc = "\t\\param *info of type timetagger4_device"]
    pub fn timetagger4_get_param_info(
        device: *mut timetagger4_device,
        info: *mut timetagger4_param_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\ingroup readout"]
    #[doc = "\t\\brief returns most recent error message"]
    #[doc = "\t\\param *device is type timetagger4_device"]
    pub fn timetagger4_get_last_error_message(
        device: *mut timetagger4_device,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\t\\ingroup readout"]
    #[doc = "\t\\brief returns the type of the device"]
    #[doc = ""]
    #[doc = "\t@link devicetype CRONO_DEVICE_TIMETAGGER4 @endlink"]
    pub fn timetagger4_get_device_type(device: *mut timetagger4_device) -> ::std::os::raw::c_int;
}
#[doc = "\t\\ingroup channel"]
#[doc = "\t\\brief Contains TDC channel settings"]
pub type timetagger4_channel = tdc4_channel;
pub type timetagger4_lowres_channel = tdc4_lowres_channel;
#[doc = "\t\\ingroup tiger"]
#[doc = "\t\\brief contains settings of timing generator"]
pub type timetagger4_tiger_block = tdc4_tiger_block;
#[doc = "\\ingroup trigger"]
#[doc = "\t\\brief contains trigger settings"]
pub type timetagger4_trigger = tdc4_trigger;
#[doc = " \\ingroup confstruct Structure timetagger4_configuration"]
#[doc = "\t\\brief\tcontains configuration information"]
#[doc = ""]
#[doc = "\tThis structure contains the configuration information. It is used in conjunction with"]
#[doc = "\t@link conffuncts timetagger4_get_default_configuration(), timetagger4_get_current_configuration()"]
#[doc = "\tand timetagger4_configure() @endlink"]
#[doc = ""]
#[doc = "\tInternally it uses the structures @link trigger timetagger4_trigger @endlink and @link tiger"]
#[doc = "\ttimetagger4_tiger_block @endlink"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timetagger4_configuration {
    #[doc = "!< The number of bytes occupied by the structure"]
    pub size: ::std::os::raw::c_int,
    #[doc = " \\brief A version number"]
    #[doc = ""]
    #[doc = " that is increased when the definition of the structure is changed. The increment"]
    #[doc = " can be larger than one to match driver version numbers or similar. Set to 0 for"]
    #[doc = " all versions up to first release."]
    pub version: ::std::os::raw::c_int,
    #[doc = " \\brief TDC mode"]
    #[doc = ""]
    #[doc = "\tcan be @link tdcmode grouped or continous @endlink. Currently supported: grouped."]
    pub tdc_mode: ::std::os::raw::c_int,
    #[doc = " \\brief rising or falling edge trigger"]
    #[doc = ""]
    #[doc = "\twhether to sync the TDC on the rising or falling edge"]
    pub start_rising: ::std::os::raw::c_uchar,
    #[doc = " \\brief Set DAC channels for T, A - D."]
    #[doc = ""]
    #[doc = "\tdc_offset[0]     : Start"]
    #[doc = ""]
    #[doc = "\tdc_offset[1 - 4] : A - D"]
    #[doc = ""]
    #[doc = "\tSet to a value between -1.65V and +0.85V. This should be close to 50% of the height of your pulses on"]
    #[doc = "\tthe inputs. Examples for various signaling standards are defined in @link defdcoffset #defines for"]
    #[doc = "\tdc_offset @endlink. The inputs are AC coupled. This means that for pulse inputs the absolute voltage is"]
    #[doc = "\tnot important. it is rather the relative pulse amplitude that causes the input circuits to switch."]
    #[doc = "\tdc_offset for an input must be set to the relative switching voltage for the input standard in use. If"]
    #[doc = "\tthe pulses are negative, a negative switching threshold must be set and vice versa."]
    pub dc_offset: [f64; 5usize],
    #[doc = "!< Configuration of external trigger sources"]
    pub trigger: [timetagger4_trigger; 16usize],
    #[doc = "!< configuration of the timing generator"]
    pub tiger_block: [timetagger4_tiger_block; 5usize],
    #[doc = "!< configure polaritiy, type and threshold for the TDC channels"]
    pub channel: [timetagger4_channel; 4usize],
    pub lowres_channel: [timetagger4_lowres_channel; 3usize],
    #[doc = " \\brief component to create a trigger either periodically or randomly."]
    #[doc = ""]
    #[doc = "  To be exact, there are two parameters M = @link auto_trigger_period auto_trigger_period @endlink"]
    #[doc = "\tand N = @link auto_trigger_random_exponent auto_trigger_random_exponent @endlink"]
    #[doc = "\tthat result in a distance between triggers of"]
    #[doc = ""]
    #[doc = "\t\tT = 1 + M + [1...2^N]"]
    #[doc = ""]
    #[doc = "\tclock cycles."]
    #[doc = ""]
    #[doc = "\t\t0 <= M < 2^32"]
    #[doc = ""]
    #[doc = "\t\t0 <= N < 32"]
    #[doc = ""]
    #[doc = "  there is no enable or reset as the usage of this trigger can be configured in the channels."]
    pub auto_trigger_period: ::std::os::raw::c_int,
    #[doc = " \\brief component to create a trigger either periodically or randomly."]
    #[doc = ""]
    #[doc = "  To be exact, there are two parameters M = @link auto_trigger_period auto_trigger_period @endlink"]
    #[doc = "\tand N = @link auto_trigger_random_exponent auto_trigger_random_exponent @endlink"]
    #[doc = "\tthat result in a distance between triggers of"]
    #[doc = ""]
    #[doc = "\t\tT = 1 + M + [1...2^N]"]
    #[doc = ""]
    #[doc = "\tclock cycles."]
    #[doc = ""]
    #[doc = "\t\t0 <= M < 2^32"]
    #[doc = ""]
    #[doc = "\t\t0 <= N < 32"]
    #[doc = ""]
    #[doc = "  there is no enable or reset as the usage of this trigger can be configured in the channels."]
    pub auto_trigger_random_exponent: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = "\t\\ingroup conffuncts"]
    #[doc = "\t\\brief gets default configuration"]
    #[doc = ""]
    #[doc = "\tCopies the default configuration to the specified config pointer. Return values are listed @link defdefconf here @endlink."]
    #[doc = "\t\\param *device of type timetagger4_device"]
    #[doc = "\t\\param *config of type timetagger4_configuration"]
    pub fn timetagger4_get_default_configuration(
        device: *mut timetagger4_device,
        config: *mut timetagger4_configuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup conffuncts"]
    #[doc = "\t\\brief gets current configuration"]
    #[doc = ""]
    #[doc = "\tCopies the current configuration to the specified config pointer. Return values are listed @link defcurconf here @endlink."]
    #[doc = "\t\\param *device of type timetagger4_device"]
    #[doc = "\t\\param *config of type timetagger4_configuration"]
    pub fn timetagger4_get_current_configuration(
        device: *mut timetagger4_device,
        config: *mut timetagger4_configuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup conffuncts"]
    #[doc = "\t\\brief configures timetagger4 device"]
    #[doc = ""]
    #[doc = "\tReturn values are listed @link defconf here @endlink."]
    #[doc = "\t\\param *device of type timetagger4_device"]
    #[doc = "\t\\param *config of type timetagger4_configuration"]
    pub fn timetagger4_configure(
        device: *mut timetagger4_device,
        config: *mut timetagger4_configuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup initfuncts"]
    #[doc = "\t\\brief Return the number of boards that are supported by this driver in the system."]
    #[doc = "\t\\param *error_code is type int"]
    #[doc = "\t\\param **error_message is type const char"]
    pub fn timetagger4_count_devices(
        error_code: *mut ::std::os::raw::c_int,
        error_message: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\ingroup initfuncts"]
    #[doc = " @{"]
    #[doc = ""]
    #[doc = "\tGets a set of default parameters for @link timetagger4_init timetagger4_init() @endlink . This must always"]
    #[doc = "\tbe used to initialize the @link initparamsstruct timetagger4_init_parameter() @endlink structure."]
    #[doc = "\tReturn values are listed @link defdefinpar here @endlink."]
    #[doc = "\t\\param init is type *timetagger4_init_parameters"]
    pub fn timetagger4_get_default_init_parameters(
        init: *mut timetagger4_init_parameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief Open and initialize the TIMETAGGER4 board with the given index."]
    #[doc = ""]
    #[doc = "\tWith error_code and error_message the user must provide pointers where error information should be"]
    #[doc = "\twritten by the driver. Return values are listed @link definit here @endlink."]
    #[doc = "\t\\param *params type timetagger4_init_parameters"]
    #[doc = "\t\\param *error_code is type int"]
    #[doc = "\t\\param **error_message is type char. The buffer for the error message has to contain at least 80 chars."]
    pub fn timetagger4_init(
        params: *mut timetagger4_init_parameters,
        error_code: *mut ::std::os::raw::c_int,
        error_message: *mut *const ::std::os::raw::c_char,
    ) -> *mut timetagger4_device;
}
#[doc = "\t\\ingroup readin"]
#[doc = "\t\\brief The parameters of the read commands"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timetagger4_read_in {
    #[doc = "!< timetagger4_read automatically acknowledges packets from the last read"]
    pub acknowledge_last_read: ::std::os::raw::c_uchar,
}
#[doc = " \\ingroup strucreadout"]
#[doc = "\t\\brief struct for the read out of the Ndigo packets"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timetagger4_read_out {
    #[doc = "\t\\brief pointer to the first packet"]
    #[doc = ""]
    #[doc = "\tthat was captured by the call of @link readout timetagger4_read @endlink"]
    pub first_packet: *mut crono_packet,
    #[doc = "\t\\brief The packet after the last one"]
    #[doc = ""]
    #[doc = "\tthis is not a valid packet"]
    pub last_packet: *mut crono_packet,
    #[doc = " \\brief error code"]
    #[doc = ""]
    #[doc = "\tThe assignments of the error codes can be found @link defread here @endlink."]
    pub error_code: ::std::os::raw::c_int,
    #[doc = "\t\\brief error message"]
    pub error_message: *const ::std::os::raw::c_char,
}
extern "C" {
    #[doc = "\t\\ingroup readout"]
    #[doc = "\t\\brief Reads packets from the board"]
    #[doc = ""]
    #[doc = "\toptionally automatically acknowledges the last read packets. Return values are listed @link defread here @endlink."]
    #[doc = "\t\\param *device is type timetagger4_device"]
    #[doc = "\t\\param *in is type timetagger4_read_in"]
    #[doc = "\t\\param *out is type timetagger4_read_out"]
    pub fn timetagger4_read(
        device: *mut timetagger4_device,
        in_: *mut timetagger4_read_in,
        out: *mut timetagger4_read_out,
    ) -> ::std::os::raw::c_int;
}
